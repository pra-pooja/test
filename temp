package main
[
    {
      "name": "pdcFactoryHQ",
      "policy": "OR('FactoryMSP.member','HQMSP.member')",
      "requiredPeerCount": 1,
      "maxPeerCount": 1,
      "blockToLive": 0,
      "memberOnlyRead": true
    },

  {
    "name": "pdcLogisticsHQ",
    "policy": "OR('LogisticsMSP.member','HQMSP.member')",
    "requiredPeerCount": 1,
    "maxPeerCount": 1,
    "blockToLive": 0,
    "memberOnlyRead": true
  },
  {
    "name": "pdcDepotHQ",
    "policy": "OR('DepotMSP.member','HQMSP.member')",
    "requiredPeerCount": 1,
    "maxPeerCount": 1,
    "blockToLive": 0,
    "memberOnlyRead": true
  }
  ]
  
import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// ====== Constants (update MSP names to match your network) ======
const (
	PDCFactoryHQ   = "pdcFactoryHQ"
	PDCLogisticsHQ = "pdcLogisticsHQ"
	PDCDepotHQ     = "pdcDepotHQ"

	FactoryMSP   = "FactoryMSP"
	LogisticsMSP = "LogisticsMSP"
	DepotMSP     = "DepotMSP"
	HQMSP        = "HQMSP"
)

// ====== Shared Data Models ======

type Batch struct {
	BatchID         string `json:"batchID"`
	Type            string `json:"type"`
	Quantity        int    `json:"quantity"`
	ManufactureDate string `json:"manufactureDate"`
	ExpiryDate      string `json:"expiryDate"`
	Status          string `json:"status"` // Created, InTransit, Stored, Issued
}

type FactorySpecs struct {
	BatchID     string `json:"batchID"`
	Composition string `json:"composition"`
	Inspection  string `json:"inspection"`
	Notes       string `json:"notes"`
	SerialCodes string `json:"serialCodes"`
	Timestamp   string `json:"timestamp"`
}

type RouteInfo struct {
	BatchID     string `json:"batchID"`
	FromOrg     string `json:"fromOrg"`
	ToOrg       string `json:"toOrg"`
	Route       string `json:"route,omitempty"`
	ConvoyID    string `json:"convoyId,omitempty"`
	ETA         string `json:"eta,omitempty"`
	Transporter string `json:"transporter,omitempty"`
	Timestamp   string `json:"timestamp"`
}

type DepotStock struct {
	BatchID        string `json:"batchID"`
	DepotOrg       string `json:"depotOrg"`
	Location       string `json:"location,omitempty"`
	Condition      string `json:"condition,omitempty"`
	QuantityOnHand int    `json:"quantityOnHand"`
	Timestamp      string `json:"timestamp"`
}

// ====== Helpers ======

func nowRFC3339() string {
	return time.Now().UTC().Format(time.RFC3339)
}

func getClientMSPID(ctx contractapi.TransactionContextInterface) (string, error) {
	msp, err := ctx.GetClientIdentity().GetMSPID()
	if err != nil {
		return "", fmt.Errorf("GetMSPID: %w", err)
	}
	return msp, nil
}

func requireMSP(ctx contractapi.TransactionContextInterface, allowed ...string) error {
	msp, err := getClientMSPID(ctx)
	if err != nil {
		return err
	}
	for _, a := range allowed {
		if msp == a {
			return nil
		}
	}
	return fmt.Errorf("access denied for org %s (allowed: %v)", msp, allowed)
}

func getBatchOrNil(ctx contractapi.TransactionContextInterface, batchID string) (*Batch, error) {
	raw, err := ctx.GetStub().GetState(batchID)
	if err != nil {
		return nil, fmt.Errorf("GetState: %w", err)
	}
	if raw == nil {
		return nil, nil
	}
	var b Batch
	if err := json.Unmarshal(raw, &b); err != nil {
		return nil, fmt.Errorf("unmarshal batch: %w", err)
	}
	return &b, nil
}

// Factory.go 
package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

type FactoryContract struct {
	contractapi.Contract
}

// CreateBatch (public): Factory creates the batch record in world state.
func (c *FactoryContract) CreateBatch(ctx contractapi.TransactionContextInterface,
	batchID, batchType string, quantity int, manufactureDate, expiryDate string) error {

	// Only Factory
	if err := requireMSP(ctx, FactoryMSP); err != nil {
		return err
	}

	// Check exists
	if existing, err := getBatchOrNil(ctx, batchID); err != nil {
		return err
	} else if existing != nil {
		return fmt.Errorf("batch %s already exists", batchID)
	}

	b := Batch{
		BatchID:         batchID,
		Type:            batchType,
		Quantity:        quantity,
		ManufactureDate: manufactureDate,
		ExpiryDate:      expiryDate,
		Status:          "Created",
	}
	j, _ := json.Marshal(b)
	return ctx.GetStub().PutState(batchID, j)
}

// CreateFactorySpecs (private): Factory writes sensitive specs to pdcFactoryHQ
func (c *FactoryContract) CreateFactorySpecs(ctx contractapi.TransactionContextInterface,
	batchID, composition, inspection, notes, serialCodes string) error {

	if err := requireMSP(ctx, FactoryMSP); err != nil {
		return err
	}
	// Ensure batch exists
	if b, err := getBatchOrNil(ctx, batchID); err != nil {
		return err
	} else if b == nil {
		return fmt.Errorf("batch %s not found", batchID)
	}

	doc := FactorySpecs{
		BatchID:     batchID,
		Composition: composition,
		Inspection:  inspection,
		Notes:       notes,
		SerialCodes: serialCodes,
		Timestamp:   nowRFC3339(),
	}
	j, _ := json.Marshal(doc)
	return ctx.GetStub().PutPrivateData(PDCFactoryHQ, batchID, j)
}

// ReadBatch (public read)
func (c *FactoryContract) ReadBatch(ctx contractapi.TransactionContextInterface, batchID string) (*Batch, error) {
	b, err := getBatchOrNil(ctx, batchID)
	if err != nil {
		return nil, err
	}
	if b == nil {
		return nil, fmt.Errorf("batch %s not found", batchID)
	}
	return b, nil
}

// ReadFactorySpecs (private read) - will succeed only if caller is in collection (Factory or HQ)
func (c *FactoryContract) ReadFactorySpecs(ctx contractapi.TransactionContextInterface, batchID string) (*FactorySpecs, error) {
	raw, err := ctx.GetStub().GetPrivateData(PDCFactoryHQ, batchID)
	if err != nil {
		return nil, fmt.Errorf("GetPrivateData(%s): %w", PDCFactoryHQ, err)
	}
	if raw == nil {
		return nil, fmt.Errorf("no factory specs for %s or not authorized", batchID)
	}
	var doc FactorySpecs
	if err := json.Unmarshal(raw, &doc); err != nil {
		return nil, fmt.Errorf("unmarshal: %w", err)
	}
	return &doc, nil
}

// Public rich queries
func (c *FactoryContract) QueryBatchesByRange(ctx contractapi.TransactionContextInterface, startKey, endKey string) ([]*Batch, error) {
	it, err := ctx.GetStub().GetStateByRange(startKey, endKey)
	if err != nil {
		return nil, err
	}
	defer it.Close()

	var out []*Batch
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var b Batch
		if err := json.Unmarshal(kv.Value, &b); err == nil {
			out = append(out, &b)
		}
	}
	return out, nil
}

func (c *FactoryContract) QueryBatchesBySelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*Batch, error) {
	it, err := ctx.GetStub().GetQueryResult(queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*Batch
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var b Batch
		if err := json.Unmarshal(kv.Value, &b); err == nil {
			out = append(out, &b)
		}
	}
	return out, nil
}

func (c *FactoryContract) QueryBatchesWithPagination(ctx contractapi.TransactionContextInterface, queryString string, pageSize int32, bookmark string) ([]*Batch, string, error) {
	it, meta, err := ctx.GetStub().GetQueryResultWithPagination(queryString, pageSize, bookmark)
	if err != nil {
		return nil, "", err
	}
	defer it.Close()
	var out []*Batch
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, "", err
		}
		var b Batch
		if err := json.Unmarshal(kv.Value, &b); err == nil {
			out = append(out, &b)
		}
	}
	return out, meta.Bookmark, nil
}

// Private rich queries for Factory PDC
func (c *FactoryContract) QueryFactorySpecsByRange(ctx contractapi.TransactionContextInterface, startKey, endKey string) ([]*FactorySpecs, error) {
	it, err := ctx.GetStub().GetPrivateDataByRange(PDCFactoryHQ, startKey, endKey)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*FactorySpecs
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec FactorySpecs
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

func (c *FactoryContract) QueryFactorySpecsSelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*FactorySpecs, error) {
	it, err := ctx.GetStub().GetPrivateDataQueryResult(PDCFactoryHQ, queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*FactorySpecs
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec FactorySpecs
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

//Logistics.go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

type LogisticsContract struct {
	contractapi.Contract
}

// TransferBatch: Logistics updates the public batch status to InTransit and writes route info to PDC
func (c *LogisticsContract) TransferBatch(ctx contractapi.TransactionContextInterface,
	batchID, fromOrg, toOrg, route, convoyID, eta, transporter string) error {

	if err := requireMSP(ctx, LogisticsMSP); err != nil {
		return err
	}
	// ensure batch exists
	b, err := getBatchOrNil(ctx, batchID)
	if err != nil {
		return err
	}
	if b == nil {
		return fmt.Errorf("batch %s not found", batchID)
	}

	// update public status
	b.Status = "InTransit"
	j, _ := json.Marshal(b)
	if err := ctx.GetStub().PutState(batchID, j); err != nil {
		return fmt.Errorf("PutState: %w", err)
	}

	// write route info in pdcLogisticsHQ
	r := RouteInfo{
		BatchID:     batchID,
		FromOrg:     fromOrg,
		ToOrg:       toOrg,
		Route:       route,
		ConvoyID:    convoyID,
		ETA:         eta,
		Transporter: transporter,
		Timestamp:   nowRFC3339(),
	}
	rj, _ := json.Marshal(r)
	return ctx.GetStub().PutPrivateData(PDCLogisticsHQ, batchID, rj)
}

// Read route info (private read; succeeds only if caller is in collection)
func (c *LogisticsContract) ReadRouteInfo(ctx contractapi.TransactionContextInterface, batchID string) (*RouteInfo, error) {
	raw, err := ctx.GetStub().GetPrivateData(PDCLogisticsHQ, batchID)
	if err != nil {
		return nil, fmt.Errorf("GetPrivateData(%s): %w", PDCLogisticsHQ, err)
	}
	if raw == nil {
		return nil, fmt.Errorf("no route info for %s or not authorized", batchID)
	}
	var r RouteInfo
	if err := json.Unmarshal(raw, &r); err != nil {
		return nil, fmt.Errorf("unmarshal: %w", err)
	}
	return &r, nil
}

// Private PDC rich queries (range + selector)
func (c *LogisticsContract) QueryRouteByRange(ctx contractapi.TransactionContextInterface, startKey, endKey string) ([]*RouteInfo, error) {
	it, err := ctx.GetStub().GetPrivateDataByRange(PDCLogisticsHQ, startKey, endKey)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*RouteInfo
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec RouteInfo
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

func (c *LogisticsContract) QueryRouteSelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*RouteInfo, error) {
	it, err := ctx.GetStub().GetPrivateDataQueryResult(PDCLogisticsHQ, queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*RouteInfo
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec RouteInfo
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}


//Depot.go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

type DepotContract struct {
	contractapi.Contract
}

// ReceiveBatch: Depot marks the batch as Stored and writes depot stock info into PDC
func (c *DepotContract) ReceiveBatch(ctx contractapi.TransactionContextInterface,
	batchID, depotOrg, location, condition string, quantityOnHand int) error {

	if err := requireMSP(ctx, DepotMSP); err != nil {
		return err
	}
	b, err := getBatchOrNil(ctx, batchID)
	if err != nil {
		return err
	}
	if b == nil {
		return fmt.Errorf("batch %s not found", batchID)
	}

	b.Status = "Stored"
	j, _ := json.Marshal(b)
	if err := ctx.GetStub().PutState(batchID, j); err != nil {
		return fmt.Errorf("PutState: %w", err)
	}

	ds := DepotStock{
		BatchID:        batchID,
		DepotOrg:       depotOrg,
		Location:       location,
		Condition:      condition,
		QuantityOnHand: quantityOnHand,
		Timestamp:      nowRFC3339(),
	}
	dsj, _ := json.Marshal(ds)
	return ctx.GetStub().PutPrivateData(PDCDepotHQ, batchID, dsj)
}

// IssueBatch: Depot marks Issued (public). Inventory adjustments can be done via PDC updates separately.
func (c *DepotContract) IssueBatch(ctx contractapi.TransactionContextInterface, batchID, toUnit string, qty int) error {
	if err := requireMSP(ctx, DepotMSP); err != nil {
		return err
	}
	b, err := getBatchOrNil(ctx, batchID)
	if err != nil {
		return err
	}
	if b == nil {
		return fmt.Errorf("batch %s not found", batchID)
	}
	b.Status = "Issued"
	j, _ := json.Marshal(b)
	if err := ctx.GetStub().PutState(batchID, j); err != nil {
		return fmt.Errorf("PutState: %w", err)
	}
	return nil
}

// Depot PDC queries
func (c *DepotContract) ReadDepotStock(ctx contractapi.TransactionContextInterface, batchID string) (*DepotStock, error) {
	raw, err := ctx.GetStub().GetPrivateData(PDCDepotHQ, batchID)
	if err != nil {
		return nil, fmt.Errorf("GetPrivateData(%s): %w", PDCDepotHQ, err)
	}
	if raw == nil {
		return nil, fmt.Errorf("no depot stock for %s or not authorized", batchID)
	}
	var ds DepotStock
	if err := json.Unmarshal(raw, &ds); err != nil {
		return nil, fmt.Errorf("unmarshal: %w", err)
	}
	return &ds, nil
}

func (c *DepotContract) QueryDepotByRange(ctx contractapi.TransactionContextInterface, startKey, endKey string) ([]*DepotStock, error) {
	it, err := ctx.GetStub().GetPrivateDataByRange(PDCDepotHQ, startKey, endKey)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*DepotStock
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec DepotStock
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

func (c *DepotContract) QueryDepotSelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*DepotStock, error) {
	it, err := ctx.GetStub().GetPrivateDataQueryResult(PDCDepotHQ, queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*DepotStock
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec DepotStock
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

//HQ.go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

type HQContract struct {
	contractapi.Contract
}

// ReadFullBatch: returns public batch + (if caller authorized) PDC docs for that batch
func (c *HQContract) ReadFullBatch(ctx contractapi.TransactionContextInterface, batchID string) (string, error) {
	// Get public
	pubRaw, err := ctx.GetStub().GetState(batchID)
	if err != nil {
		return "", fmt.Errorf("GetState: %w", err)
	}
	if pubRaw == nil {
		return "", fmt.Errorf("batch %s not found", batchID)
	}

	// Attempt to read PDCs (GetPrivateData will return nil if caller not a member)
	var factoryRaw, routeRaw, depotRaw []byte
	factoryRaw, _ = ctx.GetStub().GetPrivateData(PDCFactoryHQ, batchID)
	routeRaw, _ = ctx.GetStub().GetPrivateData(PDCLogisticsHQ, batchID)
	depotRaw, _ = ctx.GetStub().GetPrivateData(PDCDepotHQ, batchID)

	merged := map[string]json.RawMessage{
		"public":  pubRaw,
		"factory": factoryRaw,
		"route":   routeRaw,
		"depot":   depotRaw,
	}
	out, _ := json.Marshal(merged)
	return string(out), nil
}

// Audit: GetHistoryForKey (public world state history)
func (c *HQContract) AuditBatchHistory(ctx contractapi.TransactionContextInterface, batchID string) ([]string, error) {
	it, err := ctx.GetStub().GetHistoryForKey(batchID)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []string
	for it.HasNext() {
		mod, err := it.Next()
		if err != nil {
			return nil, err
		}
		rec := map[string]interface{}{
			"txId":      mod.TxId,
			"timestamp": func() string { if mod.Timestamp == nil { return "" }; return mod.Timestamp.AsTime().UTC().Format("2006-01-02T15:04:05Z07:00") }(),
			"isDelete":  mod.IsDelete,
			"value":     string(mod.Value),
		}
		j, _ := json.Marshal(rec)
		out = append(out, string(j))
	}
	return out, nil
}

// HQ-only PDC rich queries (example for factory specs)
func (c *HQContract) QueryFactorySpecsSelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*FactorySpecs, error) {
	// enforce HQ caller
	if err := requireMSP(ctx, HQMSP); err != nil {
		return nil, err
	}
	it, err := ctx.GetStub().GetPrivateDataQueryResult(PDCFactoryHQ, queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*FactorySpecs
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var rec FactorySpecs
		if err := json.Unmarshal(kv.Value, &rec); err == nil {
			out = append(out, &rec)
		}
	}
	return out, nil
}

// Public rich query wrapper (HQ)
func (c *HQContract) QueryBatchesSelector(ctx contractapi.TransactionContextInterface, queryString string) ([]*Batch, error) {
	it, err := ctx.GetStub().GetQueryResult(queryString)
	if err != nil {
		return nil, err
	}
	defer it.Close()
	var out []*Batch
	for it.HasNext() {
		kv, err := it.Next()
		if err != nil {
			return nil, err
		}
		var b Batch
		if err := json.Unmarshal(kv.Value, &b); err == nil {
			out = append(out, &b)
		}
	}
	return out, nil
}
